package ru.mephi.week1.lesson1;

public class Task2Solved {


    /**
     * <H2>–ó–∞–¥–∞—á–∞: –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –ø–æ–¥—Å—á—ë—Ç –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª</H2>
     * <br>
     * <H2>üìå –ó–∞–¥–∞–Ω–∏–µ</H2>
     * <p>–í–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç –≤—ã—á–∏—Å–ª—è—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –≤ –∑–∞–¥–∞–Ω–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ —á–∏—Å–µ–ª –æ—Ç 1 –¥–æ N. –ó–∞–¥–∞—á–∞ –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª, –∫–∞–∂–¥—ã–π –ø–æ—Ç–æ–∫ –±—É–¥–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —á–∞—Å—Ç—å –¥–∏–∞–ø–∞–∑–æ–Ω–∞ —á–∏—Å–µ–ª. –ü–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã –≤—Å–µ—Ö –ø–æ—Ç–æ–∫–æ–≤, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –¥–æ–ª–∂–Ω–∞ –≤—ã–≤–µ—Å—Ç–∏ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª.</p>
     * <br>
     * <H2>–£—Å–ª–æ–≤–∏—è</H2>
     * <ol>
     *    <li>–ß–∏—Å–ª–æ N –∑–∞–¥–∞—ë—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, N = 10000).</li>
     *    <li>–ö–∞–∂–¥—ã–π –ø–æ—Ç–æ–∫ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º —á–∏—Å–µ–ª.</li>
     *    <li>–ü–æ—Ç–æ–∫–∏ –¥–æ–ª–∂–Ω—ã —Ä–∞–±–æ—Ç–∞—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ, –≤—ã—á–∏—Å–ª—è—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –≤ —Å–≤–æ–∏—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–∞—Ö.</li>
     *    <li>–ü–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –≤—Å–µ –ø–æ—Ç–æ–∫–∏ –∑–∞–≤–µ—Ä—à–∞—Ç —Å–≤–æ—é —Ä–∞–±–æ—Ç—É, –ø—Ä–æ–≥—Ä–∞–º–º–∞ –¥–æ–ª–∂–Ω–∞ –≤—ã–≤–µ—Å—Ç–∏ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª.</li>
     * </ol>
     */

    static class PrimeCounterThread extends Thread {
        private int start, end;
        private int count = 0;

        public PrimeCounterThread(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        public void run() {
            for (int i = start; i <= end; i++) {
                if (isPrime(i)) {
                    count++;
                }
            }
        }

        private boolean isPrime(int num) {
            if (num <= 1) return false;
            for (int i = 2; i <= Math.sqrt(num); i++) {
                if (num % i == 0) {
                    return false;
                }
            }
            return true;
        }

        public int getCount() {
            return count;
        }
    }


    public static void main(String[] args) {
        int N = 10000;
        int numThreads = 4;

        PrimeCounterThread[] threads = new PrimeCounterThread[numThreads];
        int rangeSize = N / numThreads;

        for (int i = 0; i < numThreads; i++) {
            int start = i * rangeSize + 1;
            int end = (i == numThreads - 1) ? N : (i + 1) * rangeSize;
            threads[i] = new PrimeCounterThread(start, end);
            threads[i].start();
        }

        int totalPrimes = 0;
        for (int i = 0; i < numThreads; i++) {
            try {
                threads[i].join();
                totalPrimes += threads[i].getCount();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –¥–æ " + N + ": " + totalPrimes);
    }

}
